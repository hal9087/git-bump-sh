#!/usr/bin/env bash

source $(dirname $0)/bump_functions.sh

push_flag='true'
current_tag="";
new_tag="0"
release_type=""
version_file_path_name="app/config/version.yml"

#
# PARSE OPTIONS AND ARGUMENTS
#
# options:
#
# * -h : print this help
# * -s : don't push to remote
#
# ----------------------------
while getopts 'sh' flag; do
  case "${flag}" in
    h) echo_help; exit; break;;
    s) push_flag='false' ;;
    *) echo_error "Unexpected option" true; echo_help; exit 1; break;;
  esac
done

# get arguments after or before getopt
shift $(($OPTIND - 1))
first_arg=$1

# if current branch is not master abort
git_check_current_branch_is_master

# git check working directory is clean
git_check_working_directory_clean

# VERSION FILE ARGUMENT
if [ ! -z "$first_arg" ];
then version_file_path_name="${first_arg}"
fi


#
#
# RUN
#
# ---

# GIT FETCH ALL
git_fetch_all

# GET CURRENT LAST RELEASE TAG
current_tag=$(git_last_tag)
if [ -z "$current_tag" ]; then
    echo_info "can't find current tag into origin/master, assume it's the first release"
fi

if [ ! -z "$current_tag" ]; then
    #
    # CHOOSE TYPE OF RELEASE (fix, minor, major)
    #
    echo "it's a fix, a minor or a major release?"
    select release in "fix" "minor" "major"; do
        case $release in
            fix ) release_type="fix"; break;;
            minor ) release_type="minor"; break;;
            major ) release_type="major"; break;;
        esac
    done

    #
    # CALCULATE NEW RELEASE TAG
    #
    IFS='. ' read -a array <<< "$current_tag"
    if [ "${release_type}" == "fix" ];
    then let array[2]=array[2]+1;
    else
        if [ "${release_type}" == "minor" ];
        then let array[1]=array[1]+1; let array[2]="0";
        else let array[0]=array[0]+1; let array[1]="0"; let array[2]="0";
        fi
    fi
    new_tag=$(join . "${array[@]}")
else
    # FIRST RELEASE
    current_tag="(none)"
    new_tag="0.1.0"
fi

# IF NEW TAG ALREADY EXISTS, ABORT
if [ $(git_tag_exists ${new_tag}) = true ];
then echo_error "'${new_tag}' git tag already exists" true; exit 1;
fi;

# CONFIRM VERSIONS
echo_confirmation ${current_tag} ${new_tag}

# BUILD MESSAGE PARTS
new_date=$(date "+(%Y-%m-%d)")
new_header="# ${new_tag} ${new_date}"
if [ "${current_tag}" = "(none)" ]; then
    new_body="$(git_log false)"
else
    new_body="$(git_log ${current_tag})"
fi

if [ -z "$new_body" ]; then
    echo_error "no changes since last version" true; exit 1;
fi


#
#
# IO / GIT OPERATIONS
#
#--------------------
git_message="${new_tag}

${new_header}

${new_body}
"

# WRITE CHAGELOG MESSAGE TO A TEMP FILE
write_temp_changelog_md "${new_header}\n\n${new_body}\n\n"

# WRITE VERSION FILE
bump_version_file ${new_tag} ${version_file_path_name}

# UPDATE package.json
if [ $(is_npm_project) = true ]; then
    bump_npm_package_version ${new_tag}
fi;

# APPEND NEW CHANGELOG MESSAGE TO CHANGELOG.MD
update_changelog_md

# GIT ADD & COMMIT
git_add CHANGELOG.md ${version_file_path_name}

if [ $(is_npm_project) = true ]; then
    git_add package.json
fi;

git_commit "${git_message}"

# GIT ADD TAG
git_add_tag ${new_tag} "${git_message}"

# GIT PUSH MASTER AND TAG
git_push ${new_tag} ${push_flag}

# GIT "RESYNC" DEV BRANCH (REBASE AND PUSH)
git_resync_dev_branch ${push_flag}

echo -e "\nINFO. done!";
