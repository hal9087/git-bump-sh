#!/usr/bin/env bash

#
#
# FUNCTIONS
#
# --------------------
function join {
    local IFS="$1"; shift; echo "$*";
}

git_last_tag() {
    git describe origin/master
}

function git_tag_exists() {

    if git show-ref --tags | egrep -q "refs/tags/$1$"
    then
        echo true
    else
        echo false
    fi
}

git_log() {

    local format="format:- %h %s [%an]";

    if [ "$1" = false ] ; then
        git log --pretty="${format}" HEAD
    else
        git log --pretty="${format}" ${1}..HEAD
    fi;
}

git_current_branch() {
    git rev-parse --abbrev-ref HEAD
}

function echo_help() {
    echo -e "
Usage:

bump [-sh]

Options:

* -h : print this help
* -s : don't push to remote

"
}

function echo_error() {
    local error_message="ERROR.";

    if [ ! -z "$1" ]; then
        error_message=$(echo -e "${error_message} ${1}.")
    fi

    if [ "$2" = true ] ; then
        error_message=$(echo -e "${error_message} aborting.")
    fi

    echo -e "${error_message}";
}

function echo_info() {
    echo -e "INFO. ${1}."
}

# ---------------------------
#
#
# RUN
#
#
# ---------------------------

current_git_branch="$(git_current_branch)"
push_flag='true'
current_tag="";
new_tag="0"
release_type=""

#
# PARSE OPTIONS
#
# options:
#
# * -h : print this help
# * -s : don't push to remote
#
while getopts 'sh' flag; do
  case "${flag}" in
    h) echo_help; exit; break;;
    s) push_flag='false' ;;
    *) echo_error "Unexpected option" true; echo_help; exit; break;;
  esac
done

if [ ! "$current_git_branch" = "master" ]; then
    echo_error "You are not on 'master' branch. Be sure to move to 'master' branch and merge your progress" true; exit;
fi;

#
# FETCH ALL
#
if git fetch --all
then echo_info "git fetch completed"
else echo_error "" true; exit 1;
fi


current_tag=$(git_last_tag)
if [ -z "$current_tag" ]; then
    echo_info "can't find current tag into origin/master, assume it's the first release"
fi


if [ ! -z "$current_tag" ]; then
    #
    # CHOOSE TYPE OF RELEASE (fix, minor, major)
    #
    echo "it's a fix, a minor or a major release?"
    select release in "fix" "minor" "major"; do
        case $release in
            fix ) release_type="fix"; break;;
            minor ) release_type="minor"; break;;
            major ) release_type="major"; break;;
        esac
    done

    #
    # CALCULATE NEW RELEASE TAG
    #
    IFS='. ' read -a array <<< "$current_tag"
    if [ "${release_type}" == "fix" ];
    then let array[2]=array[2]+1;
    else
        if [ "${release_type}" == "minor" ];
        then let array[1]=array[1]+1; let array[2]="0";
        else let array[0]=array[0]+1; let array[1]="0"; let array[2]="0";
        fi
    fi
    new_tag=$(join . "${array[@]}")
else
    # FIRST RELEASE
    current_tag="(none)"
    new_tag="0.1.0"
fi

if [ $(git_tag_exists ${new_tag}) = true ];
then echo_error "'${new_tag}' git tag already exists" true; exit;
fi;

#
# CONFIRM INFORMATION (last and new git tags)
#
echo "

INFO

last release: '${current_tag}'
next release: '${new_tag}'

"

echo "looks right?"
select yn in "Yes" "No"; do
    case $yn in
        Yes ) break;;
        No ) echo_error "not confirmed" true; exit;;
    esac
done


# WRITE CHAGELOG MESSAGE TO A TEMP FILE
# EDIT CHANGELOG
new_date=$(date "+(%Y-%m-%d)")
new_header="# ${new_tag} ${new_date}"

if [ "${current_tag}" = "(none)" ]; then
    new_body="$(git_log false)"
else
    new_body="$(git_log ${current_tag})"
fi

if [ -z "$new_body" ]; then
    echo_error "no changes since last version" true; exit 1;
fi

echo -e "${new_header}\n\n${new_body}\n\n" > .CHANGELOG.tmp.md;

vi .CHANGELOG.md -c ":r .CHANGELOG.tmp.md"
rm -f .CHANGELOG.tmp.md;

if [ ! -f .CHANGELOG.md ]; then
    echo_error "" true; exit 1;
fi

#
# GIT OPERATIONS
#

# append changelog message
if echo -e "$(cat .CHANGELOG.md)\n\n\n$(cat CHANGELOG.md)" > CHANGELOG.md
then echo_info "CHANGELOG.md was modified"; rm -f .CHANGELOG.md;
else echo_error "" true; exit 1;
fi

# add changelog and commit
git add CHANGELOG.md;
git commit -m "
${new_tag}

${new_header}

${new_body}
";

# add tag
git tag -a ${new_tag} -m "${new_tag}";

# push master and the new tag to remote
if ${push_flag} == 'true'
then git push origin master && git push origin ${new_tag};
fi

echo "resync 'dev' branch?"
select yn in "Yes" "No"; do
    case $yn in
        Yes )
            git checkout dev && git rebase master;
            if ${push_flag} == 'true'
            then git push origin dev;
            fi;
            break;;
        No ) break;;
    esac
done

echo -e "\nINFO. done!";
